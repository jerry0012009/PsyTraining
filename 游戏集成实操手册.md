# 游戏集成实操手册

本手册提供详细的代码示例和操作步骤，帮助您快速上手游戏集成。

## 🎯 以记忆卡片游戏为例

### 步骤1：创建游戏目录结构

```bash
games/memory-cards/
├── game.html          # 游戏界面
├── game.css           # 游戏样式
└── game.js            # 游戏逻辑（主要文件）
```

### 步骤2：实现游戏类（games/memory-cards/game.js）

```javascript
/**
 * 记忆卡片游戏 - 集成到认知训练系统
 */
class MemoryCardsGame {
    constructor() {
        // 游戏状态
        this.gameState = {
            isRunning: false,
            isPaused: false,
            currentRound: 0,
            score: 0,
            level: 1,
            cards: [],
            flippedCards: [],
            matchedPairs: 0
        };
        
        // 数据记录
        this.gameData = {
            rounds: [],
            currentRoundData: null,
            totalMatches: 0,
            totalMistakes: 0
        };
        
        this.initializeGame();
        this.bindEvents();
    }

    // 🔴 必须实现 - 初始化游戏
    initializeGame() {
        this.createGameBoard();
        
        // 监听训练系统事件
        window.addEventListener('trainingSystemEvent', (event) => {
            this.handleTrainingEvent(event.detail);
        });
    }

    // 🔴 必须实现 - 处理训练系统事件
    handleTrainingEvent(eventDetail) {
        const { event } = eventDetail;
        
        switch (event) {
            case 'training_start':
                this.startFirstRound();
                break;
            case 'training_pause':
                this.pauseGame();
                break;
            case 'training_resume':
                this.resumeGame();
                break;
            case 'training_end':
                this.endAllRounds();
                break;
        }
    }

    // 游戏控制方法
    startFirstRound() {
        this.gameState.currentRound++;
        this.gameState.isRunning = true;
        this.gameState.isPaused = false;
        
        // 初始化轮次数据
        this.gameData.currentRoundData = {
            roundNumber: this.gameState.currentRound,
            startTime: Date.now(),
            endTime: null,
            duration: 0,
            score: 0,
            level: this.gameState.level,
            events: [],
            matches: 0,
            mistakes: 0,
            cardFlips: 0
        };
        
        this.setupCards();
        this.recordEvent('round_started');
    }

    startNewRound() {
        if (window.TrainingAPI && TrainingAPI.getTrainingStatus() === 'training') {
            this.gameState.level++;
            this.startFirstRound();
        }
    }

    pauseGame() {
        if (this.gameState.isRunning) {
            this.gameState.isPaused = true;
            this.gameState.isRunning = false;
            this.showPausedMessage();
        }
    }

    resumeGame() {
        if (this.gameState.isPaused) {
            this.gameState.isPaused = false;
            this.gameState.isRunning = true;
            this.hidePausedMessage();
        }
    }

    endCurrentRound() {
        if (!this.gameData.currentRoundData) return;
        
        this.gameState.isRunning = false;
        this.gameData.currentRoundData.endTime = Date.now();
        this.gameData.currentRoundData.duration = 
            this.gameData.currentRoundData.endTime - this.gameData.currentRoundData.startTime;
        this.gameData.currentRoundData.score = this.gameState.score;
        
        // 保存轮次数据
        this.gameData.rounds.push({...this.gameData.currentRoundData});
        
        // 更新总统计
        this.gameData.totalMatches += this.gameData.currentRoundData.matches;
        this.gameData.totalMistakes += this.gameData.currentRoundData.mistakes;
        
        this.recordEvent('round_ended');
        this.showRoundCompleteMessage();
        
        // 报告给训练系统
        this.reportToTrainingSystem();
    }

    endAllRounds() {
        // 如果有正在进行的轮次，先结束它
        if (this.gameState.isRunning && this.gameData.currentRoundData) {
            this.endCurrentRound();
        }
        
        this.gameState.isRunning = false;
        this.showTrainingEndMessage();
    }

    // 游戏逻辑方法
    setupCards() {
        const cardCount = 4 + (this.gameState.level - 1) * 2; // 逐级增加难度
        const pairs = cardCount / 2;
        
        this.gameState.cards = [];
        this.gameState.flippedCards = [];
        this.gameState.matchedPairs = 0;
        
        // 创建卡片对
        for (let i = 0; i < pairs; i++) {
            this.gameState.cards.push(i, i);
        }
        
        // 打乱卡片
        this.shuffleCards();
        this.renderCards();
    }

    shuffleCards() {
        for (let i = this.gameState.cards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.gameState.cards[i], this.gameState.cards[j]] = 
                [this.gameState.cards[j], this.gameState.cards[i]];
        }
    }

    handleCardClick(cardIndex) {
        if (!this.gameState.isRunning || this.gameState.isPaused) return;
        if (this.gameState.flippedCards.includes(cardIndex)) return;
        if (this.gameState.flippedCards.length >= 2) return;
        
        // 翻牌
        this.gameState.flippedCards.push(cardIndex);
        this.gameData.currentRoundData.cardFlips++;
        this.recordEvent('card_flipped', { cardIndex, cardValue: this.gameState.cards[cardIndex] });
        
        // 检查匹配
        if (this.gameState.flippedCards.length === 2) {
            setTimeout(() => this.checkMatch(), 1000);
        }
        
        this.renderCards();
    }

    checkMatch() {
        const [card1, card2] = this.gameState.flippedCards;
        const value1 = this.gameState.cards[card1];
        const value2 = this.gameState.cards[card2];
        
        if (value1 === value2) {
            // 匹配成功
            this.gameState.matchedPairs++;
            this.gameState.score += 10;
            this.gameData.currentRoundData.matches++;
            this.recordEvent('match_found', { cards: [card1, card2], value: value1 });
            
            // 检查是否完成
            if (this.gameState.matchedPairs === this.gameState.cards.length / 2) {
                this.endCurrentRound();
            }
        } else {
            // 匹配失败
            this.gameData.currentRoundData.mistakes++;
            this.recordEvent('match_failed', { cards: [card1, card2], values: [value1, value2] });
        }
        
        this.gameState.flippedCards = [];
        this.renderCards();
        this.updateScoreDisplay();
    }

    // 界面渲染方法
    renderCards() {
        const gameBoard = document.getElementById('memory-game-board');
        gameBoard.innerHTML = '';
        
        this.gameState.cards.forEach((cardValue, index) => {
            const card = document.createElement('div');
            card.className = 'memory-card';
            card.dataset.index = index;
            
            const isFlipped = this.gameState.flippedCards.includes(index);
            const isMatched = this.isCardMatched(index);
            
            if (isFlipped || isMatched) {
                card.textContent = cardValue;
                card.classList.add('flipped');
            }
            
            if (isMatched) {
                card.classList.add('matched');
            }
            
            card.addEventListener('click', () => this.handleCardClick(index));
            gameBoard.appendChild(card);
        });
    }

    isCardMatched(cardIndex) {
        const cardValue = this.gameState.cards[cardIndex];
        const matchedIndices = [];
        
        this.gameState.cards.forEach((value, index) => {
            if (value === cardValue) matchedIndices.push(index);
        });
        
        return matchedIndices.length === 2 && 
               matchedIndices.every(index => this.gameState.matchedPairs > 0);
    }

    updateScoreDisplay() {
        const scoreElement = document.getElementById('memory-score');
        if (scoreElement) {
            scoreElement.textContent = this.gameState.score;
        }
    }

    showPausedMessage() {
        const gameBoard = document.getElementById('memory-game-board');
        gameBoard.innerHTML = '<div class="game-message">游戏已暂停</div>';
    }

    hidePausedMessage() {
        this.renderCards();
    }

    showRoundCompleteMessage() {
        const gameBoard = document.getElementById('memory-game-board');
        gameBoard.innerHTML = `
            <div class="game-message">
                <h3>第${this.gameState.currentRound}轮完成！</h3>
                <p>得分: ${this.gameState.score}</p>
                <p>点击开始新一轮</p>
            </div>
        `;
    }

    showTrainingEndMessage() {
        const gameBoard = document.getElementById('memory-game-board');
        gameBoard.innerHTML = '<div class="game-message">训练结束</div>';
    }

    // 🔴 必须实现 - 记录事件
    recordEvent(type, data = {}) {
        if (this.gameData.currentRoundData) {
            this.gameData.currentRoundData.events.push({
                timestamp: Date.now(),
                type: type,
                data: data
            });
        }
    }

    // 🔴 必须实现 - 报告给训练系统
    reportToTrainingSystem() {
        const report = {
            gameType: 'memory_cards',
            currentRound: this.gameState.currentRound,
            roundData: this.gameData.currentRoundData,
            totalStats: {
                totalRounds: this.gameData.rounds.length,
                totalMatches: this.gameData.totalMatches,
                totalMistakes: this.gameData.totalMistakes,
                avgScore: this.calculateAverageScore(),
                avgLevel: this.calculateAverageLevel()
            },
            cognitiveMetrics: this.calculateCognitiveMetrics()
        };
        
        if (window.TrainingAPI) {
            TrainingAPI.reportGameData(report);
        }
    }

    // 🔴 必须实现 - 计算认知功能指标
    calculateCognitiveMetrics() {
        if (this.gameData.rounds.length === 0) return null;
        
        const rounds = this.gameData.rounds;
        const scores = rounds.map(r => r.score);
        const durations = rounds.map(r => r.duration / 1000); // 秒
        const mistakes = rounds.map(r => r.mistakes);
        const cardFlips = rounds.map(r => r.cardFlips);
        
        // 计算辅助方法
        const mean = arr => arr.reduce((sum, val) => sum + val, 0) / arr.length;
        const std = arr => {
            const m = mean(arr);
            return Math.sqrt(arr.reduce((sum, val) => sum + (val - m) ** 2, 0) / arr.length);
        };
        
        return {
            // 学习与记忆
            learningMemory: {
                workingMemory: {
                    memorySpan: mean(rounds.map(r => r.level + 1)), // 记忆广度
                    memoryAccuracy: mean(rounds.map(r => r.matches / (r.matches + r.mistakes))),
                    memoryEfficiency: mean(rounds.map(r => r.matches / r.cardFlips))
                },
                learningAbility: {
                    improvementRate: this.calculateImprovementRate(scores),
                    errorReduction: this.calculateErrorReduction(mistakes),
                    adaptationSpeed: this.calculateAdaptationSpeed(durations)
                }
            },
            
            // 注意力功能
            attention: {
                sustainedAttention: {
                    attentionSpan: mean(durations),
                    consistencyIndex: 1 - (std(scores) / Math.max(mean(scores), 1))
                },
                selectiveAttention: {
                    focusAccuracy: mean(rounds.map(r => r.matches / r.cardFlips)),
                    errorRate: mean(rounds.map(r => r.mistakes / r.cardFlips))
                }
            },
            
            // 执行功能
            executiveFunction: {
                planningAbility: {
                    strategicEfficiency: mean(rounds.map(r => r.score / r.duration * 1000))
                },
                cognitiveFlexibility: {
                    adaptabilityIndex: this.calculateAdaptabilityIndex(rounds)
                }
            },
            
            // 元数据
            analysisMetadata: {
                totalRounds: rounds.length,
                analysisTimestamp: new Date().toISOString(),
                dataQuality: this.assessDataQuality(rounds)
            }
        };
    }

    // 辅助计算方法
    calculateAverageScore() {
        return this.gameData.rounds.length > 0 ? 
            this.gameData.rounds.reduce((sum, r) => sum + r.score, 0) / this.gameData.rounds.length : 0;
    }

    calculateAverageLevel() {
        return this.gameData.rounds.length > 0 ? 
            this.gameData.rounds.reduce((sum, r) => sum + r.level, 0) / this.gameData.rounds.length : 0;
    }

    calculateImprovementRate(scores) {
        if (scores.length < 2) return 0;
        const firstHalf = scores.slice(0, Math.floor(scores.length / 2));
        const secondHalf = scores.slice(Math.floor(scores.length / 2));
        const firstAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;
        const secondAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;
        return firstAvg > 0 ? (secondAvg - firstAvg) / firstAvg : 0;
    }

    calculateErrorReduction(mistakes) {
        if (mistakes.length < 2) return 0;
        const firstMistakes = mistakes[0];
        const lastMistakes = mistakes[mistakes.length - 1];
        return firstMistakes > 0 ? (firstMistakes - lastMistakes) / firstMistakes : 0;
    }

    calculateAdaptationSpeed(durations) {
        if (durations.length < 2) return 0;
        let adaptationPoint = 0;
        for (let i = 1; i < durations.length; i++) {
            if (durations[i] < durations[i-1]) {
                adaptationPoint = i;
                break;
            }
        }
        return adaptationPoint;
    }

    calculateAdaptabilityIndex(rounds) {
        if (rounds.length < 2) return 0;
        const levelProgression = rounds.map(r => r.level);
        const scoreProgression = rounds.map(r => r.score);
        let adaptabilitySum = 0;
        
        for (let i = 1; i < rounds.length; i++) {
            if (levelProgression[i] > levelProgression[i-1] && scoreProgression[i] >= scoreProgression[i-1] * 0.8) {
                adaptabilitySum += 1;
            }
        }
        
        return adaptabilitySum / (rounds.length - 1);
    }

    assessDataQuality(rounds) {
        const minRounds = 3;
        const qualityScore = Math.min(1, rounds.length / minRounds);
        
        let quality = "优秀";
        if (qualityScore < 0.3) quality = "较差";
        else if (qualityScore < 0.6) quality = "一般";
        else if (qualityScore < 0.8) quality = "良好";
        
        return {
            score: qualityScore,
            level: quality,
            recommendation: rounds.length < minRounds ? 
                `建议至少进行${minRounds}轮游戏以获得更可靠的认知评估` : 
                "数据质量良好，可进行可靠的认知功能分析"
        };
    }

    // 事件绑定
    bindEvents() {
        // 游戏特定的事件绑定
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' && !this.gameState.isRunning && !this.gameState.isPaused) {
                this.startNewRound();
            }
        });
    }

    createGameBoard() {
        const gameContent = document.getElementById('game-content');
        const gameBoard = document.createElement('div');
        gameBoard.id = 'memory-game-board';
        gameBoard.className = 'memory-game-board';
        gameContent.appendChild(gameBoard);
    }
}

// 初始化游戏
let memoryCardsGame;

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        memoryCardsGame = new MemoryCardsGame();
        console.log('记忆卡片游戏已加载');
    });
} else {
    memoryCardsGame = new MemoryCardsGame();
    console.log('记忆卡片游戏已加载');
}
```

### 步骤3：创建游戏样式（games/memory-cards/game.css）

```css
/* 记忆卡片游戏样式 */
.memory-game-board {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 10px;
    max-width: 400px;
    margin: 20px auto;
    padding: 20px;
}

.memory-card {
    width: 80px;
    height: 80px;
    background: #3498db;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 24px;
    font-weight: bold;
    color: white;
}

.memory-card:hover {
    transform: scale(1.05);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.memory-card.flipped {
    background: #2ecc71;
    transform: rotateY(180deg);
}

.memory-card.matched {
    background: #e74c3c;
    opacity: 0.6;
    cursor: default;
}

.game-message {
    text-align: center;
    padding: 40px;
    background: rgba(255,255,255,0.9);
    border-radius: 10px;
    margin: 20px auto;
    max-width: 300px;
}

.game-message h3 {
    color: #2c3e50;
    margin-bottom: 10px;
}

.game-message p {
    color: #7f8c8d;
    margin: 5px 0;
}

/* 响应式设计 */
@media (max-width: 480px) {
    .memory-game-board {
        grid-template-columns: repeat(3, 1fr);
        max-width: 280px;
    }
    
    .memory-card {
        width: 60px;
        height: 60px;
        font-size: 18px;
    }
}
```

### 步骤4：创建游戏HTML组件（games/memory-cards/game.html）

```html
<div class="memory-cards-container">
    <div class="game-info">
        <div class="score-display">
            <h3>得分: <span id="memory-score">0</span></h3>
            <p>等级: <span id="memory-level">1</span></p>
        </div>
    </div>
    
    <div id="memory-game-board" class="memory-game-board">
        <!-- 游戏卡片将在这里动态生成 -->
    </div>
    
    <div class="game-controls">
        <button id="new-round-btn" class="game-btn">
            开始新一轮 (R)
        </button>
    </div>
</div>
```

### 步骤5：创建游戏页面（memory-cards-game.html）

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>记忆卡片游戏 - 心理测量训练</title>
    <link rel="stylesheet" href="game-template/template.css">
    <link rel="stylesheet" href="games/memory-cards/game.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="game-platform">
        <!-- 顶部控制栏 -->
        <div class="control-bar">
            <div class="control-left">
                <button id="back-btn" class="btn btn-back">
                    <i class="fas fa-arrow-left"></i>
                    返回
                </button>
                <h1 id="game-title" class="game-title">记忆卡片游戏</h1>
            </div>
            <div class="control-right">
                <div class="timer-display">
                    <i class="fas fa-clock"></i>
                    <span id="timer">00:00</span>
                </div>
                <button id="pause-btn" class="btn btn-pause">
                    <i class="fas fa-play"></i>
                    开始训练
                </button>
                <button id="end-btn" class="btn btn-end" disabled>
                    <i class="fas fa-stop"></i>
                    结束训练
                </button>
            </div>
        </div>

        <!-- 游戏容器 -->
        <div class="game-container">
            <div id="game-content" class="game-content">
                <!-- 记忆卡片游戏内容 -->
                <div class="memory-cards-container">
                    <div class="game-info">
                        <div class="score-display">
                            <h3>得分: <span id="memory-score">0</span></h3>
                            <p>等级: <span id="memory-level">1</span></p>
                        </div>
                    </div>
                    
                    <div id="memory-game-board" class="memory-game-board">
                        <!-- 游戏卡片将在这里动态生成 -->
                    </div>
                    
                    <div class="game-controls">
                        <button id="new-round-btn" class="game-btn">
                            开始新一轮 (R)
                        </button>
                    </div>
                </div>
                
                <!-- 游戏说明 -->
                <div class="game-instruction">
                    <p><strong>🎮 游戏说明</strong></p>
                    <p>🧠 点击卡片找到相同的一对，训练您的记忆力</p>
                    <p>🎯 训练目标：提高工作记忆和注意力</p>
                    <p>📈 游戏会逐级增加难度</p>
                    <p>📊 训练结束后控制台将输出详细的认知分析数据</p>
                </div>
            </div>
        </div>

        <!-- 底部信息栏 -->
        <div class="info-bar">
            <div class="session-info">
                <span>训练状态: <span id="game-status">准备中</span></span>
            </div>
            <div class="score-info">
                <span>当前得分: <span id="current-score">0</span></span>
            </div>
        </div>
    </div>

    <script src="game-template/template.js"></script>
    <script src="games/memory-cards/game.js"></script>
</body>
</html>
```

### 步骤6：更新主页（index.html）

在游戏卡片区域添加：

```html
<div class="game-card">
    <div class="game-icon">
        <i class="fas fa-brain"></i>
    </div>
    <h3>记忆卡片游戏</h3>
    <p>经典的记忆翻牌游戏，训练工作记忆和注意力。逐级增加难度，支持多轮游戏模式，系统自动记录认知表现数据。</p>
    <a href="memory-cards-game.html" class="game-btn">
        <i class="fas fa-play"></i>
        开始训练
    </a>
</div>
```

## 📊 认知分析重点

### 记忆卡片游戏主要评估：

1. **工作记忆** - 记忆广度、记忆准确性、记忆效率
2. **注意力** - 持续注意力、选择性注意力、一致性
3. **执行功能** - 策略规划、认知灵活性

### 关键指标：

- **记忆广度** - 能处理的卡片数量
- **记忆准确性** - 匹配成功率
- **学习改进** - 随轮次的进步程度
- **注意力稳定性** - 表现的一致性

## 🧪 测试验证

### 测试步骤：

1. **功能测试** - 确保游戏正常运行
2. **集成测试** - 验证与训练系统的交互
3. **数据测试** - 检查认知指标计算
4. **性能测试** - 确保流畅运行

### 测试代码：

```javascript
// 简单的测试函数
function testMemoryCardsGame() {
    console.log('开始测试记忆卡片游戏...');
    
    // 测试游戏初始化
    if (typeof memoryCardsGame !== 'undefined') {
        console.log('✅ 游戏对象创建成功');
    } else {
        console.error('❌ 游戏对象未创建');
        return;
    }
    
    // 测试方法存在性
    const requiredMethods = ['handleTrainingEvent', 'reportToTrainingSystem', 'calculateCognitiveMetrics'];
    requiredMethods.forEach(method => {
        if (typeof memoryCardsGame[method] === 'function') {
            console.log(`✅ ${method} 方法存在`);
        } else {
            console.error(`❌ ${method} 方法缺失`);
        }
    });
    
    console.log('测试完成！');
}

// 在浏览器控制台运行测试
// testMemoryCardsGame();
```

## 🎯 总结

按照这个实操手册，您可以：

1. **快速上手** - 有完整的代码示例
2. **标准实现** - 符合系统架构要求
3. **专业分析** - 提供认知功能评估
4. **易于维护** - 代码结构清晰

**下一步：** 复制这个模板，根据您的具体游戏调整逻辑和样式即可！

**参考资料：**
- Snake游戏实现：`games/snake/`
- 训练系统API：`game-template/template.js`
- 系统架构文档：`游戏集成指南.md`
</rewritten_file> 