# æ¸¸æˆé›†æˆå®æ“æ‰‹å†Œ

æœ¬æ‰‹å†Œæä¾›è¯¦ç»†çš„ä»£ç ç¤ºä¾‹å’Œæ“ä½œæ­¥éª¤ï¼Œå¸®åŠ©æ‚¨å¿«é€Ÿä¸Šæ‰‹æ¸¸æˆé›†æˆã€‚

## ğŸ¯ ä»¥è®°å¿†å¡ç‰‡æ¸¸æˆä¸ºä¾‹

### æ­¥éª¤1ï¼šåˆ›å»ºæ¸¸æˆç›®å½•ç»“æ„

```bash
games/memory-cards/
â”œâ”€â”€ game.html          # æ¸¸æˆç•Œé¢
â”œâ”€â”€ game.css           # æ¸¸æˆæ ·å¼
â””â”€â”€ game.js            # æ¸¸æˆé€»è¾‘ï¼ˆä¸»è¦æ–‡ä»¶ï¼‰
```

### æ­¥éª¤2ï¼šå®ç°æ¸¸æˆç±»ï¼ˆgames/memory-cards/game.jsï¼‰

```javascript
/**
 * è®°å¿†å¡ç‰‡æ¸¸æˆ - é›†æˆåˆ°è®¤çŸ¥è®­ç»ƒç³»ç»Ÿ
 */
class MemoryCardsGame {
    constructor() {
        // æ¸¸æˆçŠ¶æ€
        this.gameState = {
            isRunning: false,
            isPaused: false,
            currentRound: 0,
            score: 0,
            level: 1,
            cards: [],
            flippedCards: [],
            matchedPairs: 0
        };
        
        // æ•°æ®è®°å½•
        this.gameData = {
            rounds: [],
            currentRoundData: null,
            totalMatches: 0,
            totalMistakes: 0
        };
        
        this.initializeGame();
        this.bindEvents();
    }

    // ğŸ”´ å¿…é¡»å®ç° - åˆå§‹åŒ–æ¸¸æˆ
    initializeGame() {
        this.createGameBoard();
        
        // ç›‘å¬è®­ç»ƒç³»ç»Ÿäº‹ä»¶
        window.addEventListener('trainingSystemEvent', (event) => {
            this.handleTrainingEvent(event.detail);
        });
    }

    // ğŸ”´ å¿…é¡»å®ç° - å¤„ç†è®­ç»ƒç³»ç»Ÿäº‹ä»¶
    handleTrainingEvent(eventDetail) {
        const { event } = eventDetail;
        
        switch (event) {
            case 'training_start':
                this.startFirstRound();
                break;
            case 'training_pause':
                this.pauseGame();
                break;
            case 'training_resume':
                this.resumeGame();
                break;
            case 'training_end':
                this.endAllRounds();
                break;
        }
    }

    // æ¸¸æˆæ§åˆ¶æ–¹æ³•
    startFirstRound() {
        this.gameState.currentRound++;
        this.gameState.isRunning = true;
        this.gameState.isPaused = false;
        
        // åˆå§‹åŒ–è½®æ¬¡æ•°æ®
        this.gameData.currentRoundData = {
            roundNumber: this.gameState.currentRound,
            startTime: Date.now(),
            endTime: null,
            duration: 0,
            score: 0,
            level: this.gameState.level,
            events: [],
            matches: 0,
            mistakes: 0,
            cardFlips: 0
        };
        
        this.setupCards();
        this.recordEvent('round_started');
    }

    startNewRound() {
        if (window.TrainingAPI && TrainingAPI.getTrainingStatus() === 'training') {
            this.gameState.level++;
            this.startFirstRound();
        }
    }

    pauseGame() {
        if (this.gameState.isRunning) {
            this.gameState.isPaused = true;
            this.gameState.isRunning = false;
            this.showPausedMessage();
        }
    }

    resumeGame() {
        if (this.gameState.isPaused) {
            this.gameState.isPaused = false;
            this.gameState.isRunning = true;
            this.hidePausedMessage();
        }
    }

    endCurrentRound() {
        if (!this.gameData.currentRoundData) return;
        
        this.gameState.isRunning = false;
        this.gameData.currentRoundData.endTime = Date.now();
        this.gameData.currentRoundData.duration = 
            this.gameData.currentRoundData.endTime - this.gameData.currentRoundData.startTime;
        this.gameData.currentRoundData.score = this.gameState.score;
        
        // ä¿å­˜è½®æ¬¡æ•°æ®
        this.gameData.rounds.push({...this.gameData.currentRoundData});
        
        // æ›´æ–°æ€»ç»Ÿè®¡
        this.gameData.totalMatches += this.gameData.currentRoundData.matches;
        this.gameData.totalMistakes += this.gameData.currentRoundData.mistakes;
        
        this.recordEvent('round_ended');
        this.showRoundCompleteMessage();
        
        // æŠ¥å‘Šç»™è®­ç»ƒç³»ç»Ÿ
        this.reportToTrainingSystem();
    }

    endAllRounds() {
        // å¦‚æœæœ‰æ­£åœ¨è¿›è¡Œçš„è½®æ¬¡ï¼Œå…ˆç»“æŸå®ƒ
        if (this.gameState.isRunning && this.gameData.currentRoundData) {
            this.endCurrentRound();
        }
        
        this.gameState.isRunning = false;
        this.showTrainingEndMessage();
    }

    // æ¸¸æˆé€»è¾‘æ–¹æ³•
    setupCards() {
        const cardCount = 4 + (this.gameState.level - 1) * 2; // é€çº§å¢åŠ éš¾åº¦
        const pairs = cardCount / 2;
        
        this.gameState.cards = [];
        this.gameState.flippedCards = [];
        this.gameState.matchedPairs = 0;
        
        // åˆ›å»ºå¡ç‰‡å¯¹
        for (let i = 0; i < pairs; i++) {
            this.gameState.cards.push(i, i);
        }
        
        // æ‰“ä¹±å¡ç‰‡
        this.shuffleCards();
        this.renderCards();
    }

    shuffleCards() {
        for (let i = this.gameState.cards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.gameState.cards[i], this.gameState.cards[j]] = 
                [this.gameState.cards[j], this.gameState.cards[i]];
        }
    }

    handleCardClick(cardIndex) {
        if (!this.gameState.isRunning || this.gameState.isPaused) return;
        if (this.gameState.flippedCards.includes(cardIndex)) return;
        if (this.gameState.flippedCards.length >= 2) return;
        
        // ç¿»ç‰Œ
        this.gameState.flippedCards.push(cardIndex);
        this.gameData.currentRoundData.cardFlips++;
        this.recordEvent('card_flipped', { cardIndex, cardValue: this.gameState.cards[cardIndex] });
        
        // æ£€æŸ¥åŒ¹é…
        if (this.gameState.flippedCards.length === 2) {
            setTimeout(() => this.checkMatch(), 1000);
        }
        
        this.renderCards();
    }

    checkMatch() {
        const [card1, card2] = this.gameState.flippedCards;
        const value1 = this.gameState.cards[card1];
        const value2 = this.gameState.cards[card2];
        
        if (value1 === value2) {
            // åŒ¹é…æˆåŠŸ
            this.gameState.matchedPairs++;
            this.gameState.score += 10;
            this.gameData.currentRoundData.matches++;
            this.recordEvent('match_found', { cards: [card1, card2], value: value1 });
            
            // æ£€æŸ¥æ˜¯å¦å®Œæˆ
            if (this.gameState.matchedPairs === this.gameState.cards.length / 2) {
                this.endCurrentRound();
            }
        } else {
            // åŒ¹é…å¤±è´¥
            this.gameData.currentRoundData.mistakes++;
            this.recordEvent('match_failed', { cards: [card1, card2], values: [value1, value2] });
        }
        
        this.gameState.flippedCards = [];
        this.renderCards();
        this.updateScoreDisplay();
    }

    // ç•Œé¢æ¸²æŸ“æ–¹æ³•
    renderCards() {
        const gameBoard = document.getElementById('memory-game-board');
        gameBoard.innerHTML = '';
        
        this.gameState.cards.forEach((cardValue, index) => {
            const card = document.createElement('div');
            card.className = 'memory-card';
            card.dataset.index = index;
            
            const isFlipped = this.gameState.flippedCards.includes(index);
            const isMatched = this.isCardMatched(index);
            
            if (isFlipped || isMatched) {
                card.textContent = cardValue;
                card.classList.add('flipped');
            }
            
            if (isMatched) {
                card.classList.add('matched');
            }
            
            card.addEventListener('click', () => this.handleCardClick(index));
            gameBoard.appendChild(card);
        });
    }

    isCardMatched(cardIndex) {
        const cardValue = this.gameState.cards[cardIndex];
        const matchedIndices = [];
        
        this.gameState.cards.forEach((value, index) => {
            if (value === cardValue) matchedIndices.push(index);
        });
        
        return matchedIndices.length === 2 && 
               matchedIndices.every(index => this.gameState.matchedPairs > 0);
    }

    updateScoreDisplay() {
        const scoreElement = document.getElementById('memory-score');
        if (scoreElement) {
            scoreElement.textContent = this.gameState.score;
        }
    }

    showPausedMessage() {
        const gameBoard = document.getElementById('memory-game-board');
        gameBoard.innerHTML = '<div class="game-message">æ¸¸æˆå·²æš‚åœ</div>';
    }

    hidePausedMessage() {
        this.renderCards();
    }

    showRoundCompleteMessage() {
        const gameBoard = document.getElementById('memory-game-board');
        gameBoard.innerHTML = `
            <div class="game-message">
                <h3>ç¬¬${this.gameState.currentRound}è½®å®Œæˆï¼</h3>
                <p>å¾—åˆ†: ${this.gameState.score}</p>
                <p>ç‚¹å‡»å¼€å§‹æ–°ä¸€è½®</p>
            </div>
        `;
    }

    showTrainingEndMessage() {
        const gameBoard = document.getElementById('memory-game-board');
        gameBoard.innerHTML = '<div class="game-message">è®­ç»ƒç»“æŸ</div>';
    }

    // ğŸ”´ å¿…é¡»å®ç° - è®°å½•äº‹ä»¶
    recordEvent(type, data = {}) {
        if (this.gameData.currentRoundData) {
            this.gameData.currentRoundData.events.push({
                timestamp: Date.now(),
                type: type,
                data: data
            });
        }
    }

    // ğŸ”´ å¿…é¡»å®ç° - æŠ¥å‘Šç»™è®­ç»ƒç³»ç»Ÿ
    reportToTrainingSystem() {
        const report = {
            gameType: 'memory_cards',
            currentRound: this.gameState.currentRound,
            roundData: this.gameData.currentRoundData,
            totalStats: {
                totalRounds: this.gameData.rounds.length,
                totalMatches: this.gameData.totalMatches,
                totalMistakes: this.gameData.totalMistakes,
                avgScore: this.calculateAverageScore(),
                avgLevel: this.calculateAverageLevel()
            },
            cognitiveMetrics: this.calculateCognitiveMetrics()
        };
        
        if (window.TrainingAPI) {
            TrainingAPI.reportGameData(report);
        }
    }

    // ğŸ”´ å¿…é¡»å®ç° - è®¡ç®—è®¤çŸ¥åŠŸèƒ½æŒ‡æ ‡
    calculateCognitiveMetrics() {
        if (this.gameData.rounds.length === 0) return null;
        
        const rounds = this.gameData.rounds;
        const scores = rounds.map(r => r.score);
        const durations = rounds.map(r => r.duration / 1000); // ç§’
        const mistakes = rounds.map(r => r.mistakes);
        const cardFlips = rounds.map(r => r.cardFlips);
        
        // è®¡ç®—è¾…åŠ©æ–¹æ³•
        const mean = arr => arr.reduce((sum, val) => sum + val, 0) / arr.length;
        const std = arr => {
            const m = mean(arr);
            return Math.sqrt(arr.reduce((sum, val) => sum + (val - m) ** 2, 0) / arr.length);
        };
        
        return {
            // å­¦ä¹ ä¸è®°å¿†
            learningMemory: {
                workingMemory: {
                    memorySpan: mean(rounds.map(r => r.level + 1)), // è®°å¿†å¹¿åº¦
                    memoryAccuracy: mean(rounds.map(r => r.matches / (r.matches + r.mistakes))),
                    memoryEfficiency: mean(rounds.map(r => r.matches / r.cardFlips))
                },
                learningAbility: {
                    improvementRate: this.calculateImprovementRate(scores),
                    errorReduction: this.calculateErrorReduction(mistakes),
                    adaptationSpeed: this.calculateAdaptationSpeed(durations)
                }
            },
            
            // æ³¨æ„åŠ›åŠŸèƒ½
            attention: {
                sustainedAttention: {
                    attentionSpan: mean(durations),
                    consistencyIndex: 1 - (std(scores) / Math.max(mean(scores), 1))
                },
                selectiveAttention: {
                    focusAccuracy: mean(rounds.map(r => r.matches / r.cardFlips)),
                    errorRate: mean(rounds.map(r => r.mistakes / r.cardFlips))
                }
            },
            
            // æ‰§è¡ŒåŠŸèƒ½
            executiveFunction: {
                planningAbility: {
                    strategicEfficiency: mean(rounds.map(r => r.score / r.duration * 1000))
                },
                cognitiveFlexibility: {
                    adaptabilityIndex: this.calculateAdaptabilityIndex(rounds)
                }
            },
            
            // å…ƒæ•°æ®
            analysisMetadata: {
                totalRounds: rounds.length,
                analysisTimestamp: new Date().toISOString(),
                dataQuality: this.assessDataQuality(rounds)
            }
        };
    }

    // è¾…åŠ©è®¡ç®—æ–¹æ³•
    calculateAverageScore() {
        return this.gameData.rounds.length > 0 ? 
            this.gameData.rounds.reduce((sum, r) => sum + r.score, 0) / this.gameData.rounds.length : 0;
    }

    calculateAverageLevel() {
        return this.gameData.rounds.length > 0 ? 
            this.gameData.rounds.reduce((sum, r) => sum + r.level, 0) / this.gameData.rounds.length : 0;
    }

    calculateImprovementRate(scores) {
        if (scores.length < 2) return 0;
        const firstHalf = scores.slice(0, Math.floor(scores.length / 2));
        const secondHalf = scores.slice(Math.floor(scores.length / 2));
        const firstAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;
        const secondAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;
        return firstAvg > 0 ? (secondAvg - firstAvg) / firstAvg : 0;
    }

    calculateErrorReduction(mistakes) {
        if (mistakes.length < 2) return 0;
        const firstMistakes = mistakes[0];
        const lastMistakes = mistakes[mistakes.length - 1];
        return firstMistakes > 0 ? (firstMistakes - lastMistakes) / firstMistakes : 0;
    }

    calculateAdaptationSpeed(durations) {
        if (durations.length < 2) return 0;
        let adaptationPoint = 0;
        for (let i = 1; i < durations.length; i++) {
            if (durations[i] < durations[i-1]) {
                adaptationPoint = i;
                break;
            }
        }
        return adaptationPoint;
    }

    calculateAdaptabilityIndex(rounds) {
        if (rounds.length < 2) return 0;
        const levelProgression = rounds.map(r => r.level);
        const scoreProgression = rounds.map(r => r.score);
        let adaptabilitySum = 0;
        
        for (let i = 1; i < rounds.length; i++) {
            if (levelProgression[i] > levelProgression[i-1] && scoreProgression[i] >= scoreProgression[i-1] * 0.8) {
                adaptabilitySum += 1;
            }
        }
        
        return adaptabilitySum / (rounds.length - 1);
    }

    assessDataQuality(rounds) {
        const minRounds = 3;
        const qualityScore = Math.min(1, rounds.length / minRounds);
        
        let quality = "ä¼˜ç§€";
        if (qualityScore < 0.3) quality = "è¾ƒå·®";
        else if (qualityScore < 0.6) quality = "ä¸€èˆ¬";
        else if (qualityScore < 0.8) quality = "è‰¯å¥½";
        
        return {
            score: qualityScore,
            level: quality,
            recommendation: rounds.length < minRounds ? 
                `å»ºè®®è‡³å°‘è¿›è¡Œ${minRounds}è½®æ¸¸æˆä»¥è·å¾—æ›´å¯é çš„è®¤çŸ¥è¯„ä¼°` : 
                "æ•°æ®è´¨é‡è‰¯å¥½ï¼Œå¯è¿›è¡Œå¯é çš„è®¤çŸ¥åŠŸèƒ½åˆ†æ"
        };
    }

    // äº‹ä»¶ç»‘å®š
    bindEvents() {
        // æ¸¸æˆç‰¹å®šçš„äº‹ä»¶ç»‘å®š
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' && !this.gameState.isRunning && !this.gameState.isPaused) {
                this.startNewRound();
            }
        });
    }

    createGameBoard() {
        const gameContent = document.getElementById('game-content');
        const gameBoard = document.createElement('div');
        gameBoard.id = 'memory-game-board';
        gameBoard.className = 'memory-game-board';
        gameContent.appendChild(gameBoard);
    }
}

// åˆå§‹åŒ–æ¸¸æˆ
let memoryCardsGame;

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        memoryCardsGame = new MemoryCardsGame();
        console.log('è®°å¿†å¡ç‰‡æ¸¸æˆå·²åŠ è½½');
    });
} else {
    memoryCardsGame = new MemoryCardsGame();
    console.log('è®°å¿†å¡ç‰‡æ¸¸æˆå·²åŠ è½½');
}
```

### æ­¥éª¤3ï¼šåˆ›å»ºæ¸¸æˆæ ·å¼ï¼ˆgames/memory-cards/game.cssï¼‰

```css
/* è®°å¿†å¡ç‰‡æ¸¸æˆæ ·å¼ */
.memory-game-board {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 10px;
    max-width: 400px;
    margin: 20px auto;
    padding: 20px;
}

.memory-card {
    width: 80px;
    height: 80px;
    background: #3498db;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 24px;
    font-weight: bold;
    color: white;
}

.memory-card:hover {
    transform: scale(1.05);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.memory-card.flipped {
    background: #2ecc71;
    transform: rotateY(180deg);
}

.memory-card.matched {
    background: #e74c3c;
    opacity: 0.6;
    cursor: default;
}

.game-message {
    text-align: center;
    padding: 40px;
    background: rgba(255,255,255,0.9);
    border-radius: 10px;
    margin: 20px auto;
    max-width: 300px;
}

.game-message h3 {
    color: #2c3e50;
    margin-bottom: 10px;
}

.game-message p {
    color: #7f8c8d;
    margin: 5px 0;
}

/* å“åº”å¼è®¾è®¡ */
@media (max-width: 480px) {
    .memory-game-board {
        grid-template-columns: repeat(3, 1fr);
        max-width: 280px;
    }
    
    .memory-card {
        width: 60px;
        height: 60px;
        font-size: 18px;
    }
}
```

### æ­¥éª¤4ï¼šåˆ›å»ºæ¸¸æˆHTMLç»„ä»¶ï¼ˆgames/memory-cards/game.htmlï¼‰

```html
<div class="memory-cards-container">
    <div class="game-info">
        <div class="score-display">
            <h3>å¾—åˆ†: <span id="memory-score">0</span></h3>
            <p>ç­‰çº§: <span id="memory-level">1</span></p>
        </div>
    </div>
    
    <div id="memory-game-board" class="memory-game-board">
        <!-- æ¸¸æˆå¡ç‰‡å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
    </div>
    
    <div class="game-controls">
        <button id="new-round-btn" class="game-btn">
            å¼€å§‹æ–°ä¸€è½® (R)
        </button>
    </div>
</div>
```

### æ­¥éª¤5ï¼šåˆ›å»ºæ¸¸æˆé¡µé¢ï¼ˆmemory-cards-game.htmlï¼‰

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è®°å¿†å¡ç‰‡æ¸¸æˆ - å¿ƒç†æµ‹é‡è®­ç»ƒ</title>
    <link rel="stylesheet" href="game-template/template.css">
    <link rel="stylesheet" href="games/memory-cards/game.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="game-platform">
        <!-- é¡¶éƒ¨æ§åˆ¶æ  -->
        <div class="control-bar">
            <div class="control-left">
                <button id="back-btn" class="btn btn-back">
                    <i class="fas fa-arrow-left"></i>
                    è¿”å›
                </button>
                <h1 id="game-title" class="game-title">è®°å¿†å¡ç‰‡æ¸¸æˆ</h1>
            </div>
            <div class="control-right">
                <div class="timer-display">
                    <i class="fas fa-clock"></i>
                    <span id="timer">00:00</span>
                </div>
                <button id="pause-btn" class="btn btn-pause">
                    <i class="fas fa-play"></i>
                    å¼€å§‹è®­ç»ƒ
                </button>
                <button id="end-btn" class="btn btn-end" disabled>
                    <i class="fas fa-stop"></i>
                    ç»“æŸè®­ç»ƒ
                </button>
            </div>
        </div>

        <!-- æ¸¸æˆå®¹å™¨ -->
        <div class="game-container">
            <div id="game-content" class="game-content">
                <!-- è®°å¿†å¡ç‰‡æ¸¸æˆå†…å®¹ -->
                <div class="memory-cards-container">
                    <div class="game-info">
                        <div class="score-display">
                            <h3>å¾—åˆ†: <span id="memory-score">0</span></h3>
                            <p>ç­‰çº§: <span id="memory-level">1</span></p>
                        </div>
                    </div>
                    
                    <div id="memory-game-board" class="memory-game-board">
                        <!-- æ¸¸æˆå¡ç‰‡å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                    
                    <div class="game-controls">
                        <button id="new-round-btn" class="game-btn">
                            å¼€å§‹æ–°ä¸€è½® (R)
                        </button>
                    </div>
                </div>
                
                <!-- æ¸¸æˆè¯´æ˜ -->
                <div class="game-instruction">
                    <p><strong>ğŸ® æ¸¸æˆè¯´æ˜</strong></p>
                    <p>ğŸ§  ç‚¹å‡»å¡ç‰‡æ‰¾åˆ°ç›¸åŒçš„ä¸€å¯¹ï¼Œè®­ç»ƒæ‚¨çš„è®°å¿†åŠ›</p>
                    <p>ğŸ¯ è®­ç»ƒç›®æ ‡ï¼šæé«˜å·¥ä½œè®°å¿†å’Œæ³¨æ„åŠ›</p>
                    <p>ğŸ“ˆ æ¸¸æˆä¼šé€çº§å¢åŠ éš¾åº¦</p>
                    <p>ğŸ“Š è®­ç»ƒç»“æŸåæ§åˆ¶å°å°†è¾“å‡ºè¯¦ç»†çš„è®¤çŸ¥åˆ†ææ•°æ®</p>
                </div>
            </div>
        </div>

        <!-- åº•éƒ¨ä¿¡æ¯æ  -->
        <div class="info-bar">
            <div class="session-info">
                <span>è®­ç»ƒçŠ¶æ€: <span id="game-status">å‡†å¤‡ä¸­</span></span>
            </div>
            <div class="score-info">
                <span>å½“å‰å¾—åˆ†: <span id="current-score">0</span></span>
            </div>
        </div>
    </div>

    <script src="game-template/template.js"></script>
    <script src="games/memory-cards/game.js"></script>
</body>
</html>
```

### æ­¥éª¤6ï¼šæ›´æ–°ä¸»é¡µï¼ˆindex.htmlï¼‰

åœ¨æ¸¸æˆå¡ç‰‡åŒºåŸŸæ·»åŠ ï¼š

```html
<div class="game-card">
    <div class="game-icon">
        <i class="fas fa-brain"></i>
    </div>
    <h3>è®°å¿†å¡ç‰‡æ¸¸æˆ</h3>
    <p>ç»å…¸çš„è®°å¿†ç¿»ç‰Œæ¸¸æˆï¼Œè®­ç»ƒå·¥ä½œè®°å¿†å’Œæ³¨æ„åŠ›ã€‚é€çº§å¢åŠ éš¾åº¦ï¼Œæ”¯æŒå¤šè½®æ¸¸æˆæ¨¡å¼ï¼Œç³»ç»Ÿè‡ªåŠ¨è®°å½•è®¤çŸ¥è¡¨ç°æ•°æ®ã€‚</p>
    <a href="memory-cards-game.html" class="game-btn">
        <i class="fas fa-play"></i>
        å¼€å§‹è®­ç»ƒ
    </a>
</div>
```

## ğŸ“Š è®¤çŸ¥åˆ†æé‡ç‚¹

### è®°å¿†å¡ç‰‡æ¸¸æˆä¸»è¦è¯„ä¼°ï¼š

1. **å·¥ä½œè®°å¿†** - è®°å¿†å¹¿åº¦ã€è®°å¿†å‡†ç¡®æ€§ã€è®°å¿†æ•ˆç‡
2. **æ³¨æ„åŠ›** - æŒç»­æ³¨æ„åŠ›ã€é€‰æ‹©æ€§æ³¨æ„åŠ›ã€ä¸€è‡´æ€§
3. **æ‰§è¡ŒåŠŸèƒ½** - ç­–ç•¥è§„åˆ’ã€è®¤çŸ¥çµæ´»æ€§

### å…³é”®æŒ‡æ ‡ï¼š

- **è®°å¿†å¹¿åº¦** - èƒ½å¤„ç†çš„å¡ç‰‡æ•°é‡
- **è®°å¿†å‡†ç¡®æ€§** - åŒ¹é…æˆåŠŸç‡
- **å­¦ä¹ æ”¹è¿›** - éšè½®æ¬¡çš„è¿›æ­¥ç¨‹åº¦
- **æ³¨æ„åŠ›ç¨³å®šæ€§** - è¡¨ç°çš„ä¸€è‡´æ€§

## ğŸ§ª æµ‹è¯•éªŒè¯

### æµ‹è¯•æ­¥éª¤ï¼š

1. **åŠŸèƒ½æµ‹è¯•** - ç¡®ä¿æ¸¸æˆæ­£å¸¸è¿è¡Œ
2. **é›†æˆæµ‹è¯•** - éªŒè¯ä¸è®­ç»ƒç³»ç»Ÿçš„äº¤äº’
3. **æ•°æ®æµ‹è¯•** - æ£€æŸ¥è®¤çŸ¥æŒ‡æ ‡è®¡ç®—
4. **æ€§èƒ½æµ‹è¯•** - ç¡®ä¿æµç•…è¿è¡Œ

### æµ‹è¯•ä»£ç ï¼š

```javascript
// ç®€å•çš„æµ‹è¯•å‡½æ•°
function testMemoryCardsGame() {
    console.log('å¼€å§‹æµ‹è¯•è®°å¿†å¡ç‰‡æ¸¸æˆ...');
    
    // æµ‹è¯•æ¸¸æˆåˆå§‹åŒ–
    if (typeof memoryCardsGame !== 'undefined') {
        console.log('âœ… æ¸¸æˆå¯¹è±¡åˆ›å»ºæˆåŠŸ');
    } else {
        console.error('âŒ æ¸¸æˆå¯¹è±¡æœªåˆ›å»º');
        return;
    }
    
    // æµ‹è¯•æ–¹æ³•å­˜åœ¨æ€§
    const requiredMethods = ['handleTrainingEvent', 'reportToTrainingSystem', 'calculateCognitiveMetrics'];
    requiredMethods.forEach(method => {
        if (typeof memoryCardsGame[method] === 'function') {
            console.log(`âœ… ${method} æ–¹æ³•å­˜åœ¨`);
        } else {
            console.error(`âŒ ${method} æ–¹æ³•ç¼ºå¤±`);
        }
    });
    
    console.log('æµ‹è¯•å®Œæˆï¼');
}

// åœ¨æµè§ˆå™¨æ§åˆ¶å°è¿è¡Œæµ‹è¯•
// testMemoryCardsGame();
```

## ğŸ¯ æ€»ç»“

æŒ‰ç…§è¿™ä¸ªå®æ“æ‰‹å†Œï¼Œæ‚¨å¯ä»¥ï¼š

1. **å¿«é€Ÿä¸Šæ‰‹** - æœ‰å®Œæ•´çš„ä»£ç ç¤ºä¾‹
2. **æ ‡å‡†å®ç°** - ç¬¦åˆç³»ç»Ÿæ¶æ„è¦æ±‚
3. **ä¸“ä¸šåˆ†æ** - æä¾›è®¤çŸ¥åŠŸèƒ½è¯„ä¼°
4. **æ˜“äºç»´æŠ¤** - ä»£ç ç»“æ„æ¸…æ™°

**ä¸‹ä¸€æ­¥ï¼š** å¤åˆ¶è¿™ä¸ªæ¨¡æ¿ï¼Œæ ¹æ®æ‚¨çš„å…·ä½“æ¸¸æˆè°ƒæ•´é€»è¾‘å’Œæ ·å¼å³å¯ï¼

**å‚è€ƒèµ„æ–™ï¼š**
- Snakeæ¸¸æˆå®ç°ï¼š`games/snake/`
- è®­ç»ƒç³»ç»ŸAPIï¼š`game-template/template.js`
- ç³»ç»Ÿæ¶æ„æ–‡æ¡£ï¼š`æ¸¸æˆé›†æˆæŒ‡å—.md`
</rewritten_file> 